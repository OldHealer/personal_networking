# Архитектурное видение: Rockfile — Картотека контактов в стиле Рокфеллера

## 1. Обзор продукта

**Rockfile** — приложение для управления персональной картотекой контактов по методологии Джона Рокфеллера. Цель — превратить обычные контакты в инструмент для построения осознанных, персонализированных отношений за счёт структурированного хранения детальной информации о каждом человеке.

---

## 2. Основные принципы проектирования

- **Персонализация превыше всего** — каждый контакт должен содержать максимум контекста для тёплого, осмысленного общения.
- **Структурированность** — данные организованы по категориям (как у Рокфеллера), а не в виде хаотичных заметок.
- **Историчность** — сохраняем хронологию взаимодействий и важные детали из прошлых встреч.
- **Расширяемость** — архитектура допускает добавление функций (напоминания, связи между контактами, аналитика).

---

## 3. Сущности и доменная модель

### 3.1. Диаграмма сущностей (ER)

**Принцип:** Каждый человек — полноценная карточка (ContactCard). Связи между людьми — через ContactLink. Семья, коллеги, знакомые — все равноправные контакты с разными типами связей.

```
                    ┌─────────────────────────────────────────────────────────────────┐
                    │              ContactCard (Карточка контакта)                     │
                    │  Один человек = одна карточка. Иван, Жанна, Коля, Витя — все     │
                    │  имеют полную карточку с контактами, интересами, историей.       │
                    ├─────────────────────────────────────────────────────────────────┤
                    │  id, full_name, address, phone, email, socials                   │
                    │  first_met_at, first_met_place, first_met_context                │
                    │  relationship_type*, known_through_contact_id*                   │
                    │  hobbies[], interests[], family_status, birthday                 │
                    │  last_contact_at, last_contact_summary, promises[], goals[]...   │
                    └───────────┬─────────────────────┬──────────────────┬─────────────┘
                                │                     │                  │
            ┌───────────────────┘                     │                  └───────────────────┐
            │ 1:N                                     │ 1:N                                │
            ▼                                         ▼                                    │
┌───────────────────────────────┐       ┌───────────────────────────────┐                  │
│  ContactInteraction           │       │  ContactLink                  │                  │
│  Встречи, звонки, переписки   │       │  Связь между двумя контактами │◄─────────────────┘
├───────────────────────────────┤       ├───────────────────────────────┤   N:N (через
│  id, contact_id               │       │  contact_id_a, contact_id_b   │    ContactLink)
│  occurred_at, channel, place  │       │  relationship_type            │
│  summary, notes               │       │  context, is_directed         │
│  promises[], mentions[]       │       └───────────────────────────────┘
└───────────────────────────────┘       spouse, friend, colleague, parent, child...
```

\* `relationship_type` на карточке — как **я** знаю этого человека. `known_through_contact_id` — через кого познакомился.

### 3.2. Описание сущностей

#### ContactCard (Карточка контакта)


| Группа данных         | Поля                                                                   | Описание                                                 |
| --------------------- | ---------------------------------------------------------------------- | -------------------------------------------------------- |
| **Идентификация**     | `full_name`, `address`, `phone`, `email`, `socials`                    | Полное имя и все контактные данные, соцсети в JSON       |
| **Знакомство**        | `first_met_at`, `first_met_place`, `first_met_context`                 | Когда, где и при каких обстоятельствах познакомились     |
| **Отношения**         | `relationship_type`, `projects_notes`                                  | Тип (деловые/личные) и проекты/договорённости            |
| **Интересы**          | `hobbies`, `interests`                                                 | Хобби и личные интересы (массивы)                        |
| **Семья**             | `family_status`, `birthday`                                            | Положение, день рождения (о самом контакте)             |
| **Последний контакт** | `last_contact_at`, `last_contact_summary`                              | Дата и краткая суть последнего общения                   |
| **Особые моменты**    | `promises`, `recommendations`, `competence_rating`, `competence_notes` | Обещания, рекомендации, оценка компетенций               |
| **Цели**              | `goals`, `ambitions`                                                   | Планы на будущее и амбиции                               |


#### ContactLink (Связи между контактами) — подробно

##### Две разные вещи: «я ↔ контакт» и «контакт ↔ контакт»

В картотеке есть **два уровня** отношений:

1. **Как я знаю человека** — хранится **на карточке** (`ContactCard.relationship_type`, `known_through_contact_id`).  
   Примеры: коллега, брат, знакомый, «узнал через Ивана».

2. **Как мои контакты связаны друг с другом** — хранится в **ContactLink**.  
   Примеры: Иван и Жанна — супруги, Жанна и Коля — друзья.

ContactLink нужен именно для **связей между моими контактами**, а не для связи «я ↔ контакт».

---

##### Что такое ContactLink

**ContactLink** — это запись о том, что **два человека из моей картотеки** как-то связаны между собой.

Одна запись ContactLink = одна связь между двумя карточками (двумя людьми).

| Поле                | Тип     | Описание |
|---------------------|---------|----------|
| `id`                | UUID    | Идентификатор связи |
| `contact_id_a`      | UUID    | ID первой карточки (первый человек) |
| `contact_id_b`      | UUID    | ID второй карточки (второй человек) |
| `relationship_type` | enum    | Тип связи: `spouse`, `friend`, `colleague`, `parent`, `child`, `sibling`, `acquaintance`, `met_through`, `other` |
| `context`           | text    | Пояснение («супруга Ивана», «друг Жанны», «познакомились на конференции») |
| `is_directed`       | bool    | Если `true` — связь направлена от A к B (напр. «A — начальник B»). Иначе — симметричная (друзья, супруги) |
| `created_at`        | datetime| Когда связь добавлена |

---

##### Когда создавать ContactLink

ContactLink создаётся, когда ты фиксируешь: «эти два человека из моей картотеки **знают друг друга** (или связаны)».

Примеры:
- «Жанна — жена Ивана» → Link(Иван, Жанна, spouse)
- «Коля и Витя — друзья Жанны» → Link(Жанна, Коля, friend), Link(Жанна, Витя, friend)
- «Петров познакомил меня с Сидоровым» → Link(Петров, Сидоров, met_through), context: «Петров познакомил»
- «Мария — дочь Сергея» → Link(Сергей, Мария, parent), is_directed=true

---

##### Пример: граф отношений

> У меня есть коллега Иван. У Ивана супруга Жанна. У Жанны два друга — Коля и Витя. Коля — мой брат, Витя — мой знакомый.

**Карточки (ContactCard):** у каждого человека своя карточка: Иван, Жанна, Коля, Витя.

**Моя связь с каждым** (на карточке):
- Иван: `relationship_type = colleague`
- Жанна: `relationship_type = contact_of_contact`, `known_through_contact_id = Ivan`
- Коля: `relationship_type = brother`
- Витя: `relationship_type = acquaintance`

**Связи между ними** (ContactLink):

| contact_id_a | contact_id_b | relationship_type | context          |
|--------------|--------------|-------------------|------------------|
| Иван         | Жанна        | spouse            | жена Ивана       |
| Жанна        | Коля         | friend            | друг Жанны       |
| Жанна        | Витя         | friend            | друг Жанны       |

Визуально:

```
        [Я]
         │
    ┌────┼────┬────────┐
    │    │    │        │
  Иван  Коля Витя   Жанна
 (колл) (брат)(знак)  │
    │                 │
    └────── spouse ───┘
              │
         friend│friend
          ┌────┴────┐
        Коля      Витя
```

Иван связан со мной (коллега) и с Жанной (супруга). Жанна связана с Иваном, Колей и Витей. Коля и Витя связаны и со мной (брат, знакомый), и с Жанной (друзья).

---

##### Зачем это нужно

| Вопрос / задача                       | Как помогает ContactLink                          |
|--------------------------------------|---------------------------------------------------|
| Кого попросить познакомить с Витей?  | Ищем контактов, связанных с Витей → Жанна         |
| Кто Жанна для Ивана?                 | Смотрим Link(Иван, Жанна) → spouse                |
| С кем можно поднять тему «жена Ивана»? | Видно, что Жанна — супруга Ивана                |
| Кто может знать Колю?                | Связь Жанна–Коля (friend)                         |

Без ContactLink мы знаем только «как я знаю каждого», но не «кто кого знает». С ContactLink получается **граф людей и их отношений**.

---

##### Направленные и ненаправленные связи

- **Симметричные** (`is_directed = false`): друзья, супруги, коллеги — связь двусторонняя.
- **Направленные** (`is_directed = true`): родитель→ребёнок, начальник→подчинённый, «A познакомил B».

При направленной связи порядок `contact_id_a` и `contact_id_b` имеет смысл: A — источник, B — цель (например, «Иван — начальник Петра»).

---

##### Поля на ContactCard для «моей» перспективы

- `relationship_type` — как **я** знаю этого человека (colleague, brother, acquaintance, contact_of_contact…).
- `known_through_contact_id` — через кого познакомился (опционально). Для Жанны = ID Ивана.

---

#### ContactInteraction (Взаимодействия) — детально

Связан с `ContactCard`. Каждое взаимодействие — единичный акт общения: встреча, звонок, переписка. Фиксируется **что произошло** и **что из этого следует**.


| Поле           | Тип      | Описание                                              |
| -------------- | -------- | ----------------------------------------------------- |
| `id`           | UUID     | Идентификатор взаимодействия                          |
| `contact_id`   | UUID     | Ссылка на карточку                                    |
| `occurred_at`  | datetime | Дата и время контакта                                 |
| `channel`      | enum     | Канал: `meeting`, `call`, `message`, `email`, `other` |
| `place`        | str      | Место встречи (если применимо)                        |
| `summary`      | text     | Краткая суть разговора                                |
| `notes`        | text     | Подробные заметки, детали                             |
| `promises`     | JSON[]   | Обещания, возникшие в **этом** контакте               |
| `mentions`     | JSON[]   | Упоминания, темы, идеи (что обсуждали)                |
| `follow_up_by` | date     | К какому сроку нужен follow-up (опционально)          |


**Что вносить при каждом контакте:**

- Дата, канал, краткая суть и заметки.
- **Обещания** — конкретные договорённости, родившиеся в этом взаимодействии (я обещал перезвонить, он обещал прислать материалы, договорились встретиться в пятницу).
- **Mentions** — важные темы, упомянутые проекты, идеи для будущих разговоров.

---

#### Связь обещаний: ContactInteraction ↔ ContactCard

**Принцип:** `promises` в **ContactInteraction** — источник правды для конкретного контакта. `promises` в **ContactCard** — агрегированный список *активных* обещаний по всем взаимодействиям.


| Где хранится                    | Смысл                                                                                             |
| ------------------------------- | ------------------------------------------------------------------------------------------------- |
| **ContactInteraction.promises** | Обещания, появившиеся в *данном* взаимодействии. Исторический контекст: когда, в каком разговоре. |
| **ContactCard.promises**        | Сводка активных/невыполненных обещаний. Для быстрого доступа и напоминаний.                       |


**Поток данных:**

1. При добавлении Interaction с `promises` — сервис **добавляет** эти обещания в `ContactCard.promises` (с привязкой к `interaction_id` для трассировки).
2. При выполнении обещания — оно помечается как выполненное (флаг `completed`) или удаляется из `ContactCard.promises`, но остаётся в Interaction как история.
3. Структура обещания: `{ "text": "...", "direction": "i_gave" | "they_gave", "interaction_id": "...", "completed_at": null | datetime }`.

Таким образом, в карточке виден актуальный список «что надо сделать», а в истории взаимодействий — откуда каждое обещание взялось.

### 3.3. Дополнительные сущности (рекомендуемые для расширения)

| Сущность            | Назначение                                          |
| ------------------- | --------------------------------------------------- |
| **ContactTag**      | Теги для группировки (по сфере, проекту, географии) |
| **ContactReminder** | Напоминания о follow-up, днях рождения, обещаниях   |
| **User**            | Владелец картотеки (для мультитенантности)          |

*ContactLink — базовая сущность (см. выше), не расширение.*


---

## 4. Взаимодействие компонентов

### 4.1. Слои приложения

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  API Layer (FastAPI)                                                         │
│  Роутеры, валидация запросов (Pydantic), обработка ошибок                    │
└────────────────────────────────────────┬────────────────────────────────────┘
                                         │
┌────────────────────────────────────────▼────────────────────────────────────┐
│  Service Layer (бизнес-логика)                                               │
│  Карточки, связи (ContactLink), Interaction, агрегация обещаний,            │
│  напоминания, поиск, фильтрация                                              │
└────────────────────────────────────────┬────────────────────────────────────┘
                                         │
┌────────────────────────────────────────▼────────────────────────────────────┐
│  Repository / DAO Layer                                                      │
│  CRUD, запросы с фильтрами, пагинация                                        │
└────────────────────────────────────────┬────────────────────────────────────┘
                                         │
┌────────────────────────────────────────▼────────────────────────────────────┐
│  Database (PostgreSQL)                                                       │
│  SQLAlchemy 2.0 (async), Alembic для миграций                                │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2. Потоки данных

1. **Создание карточки**: API → Service → DAO → DB. При необходимости создаются ContactLink (связи с другими контактами).
2. **Добавление взаимодействия**: API → Service → DAO. Service обновляет `last_contact_at` и `last_contact_summary` у ContactCard.
3. **Добавление связи**: API → Service → DAO. Создаётся ContactLink между двумя ContactCard.
4. **Поиск и фильтрация**: API (query params) → Service (построение фильтров) → DAO (SQL) → пагинация → ответ.

---

## 5. Технологический стек

### 5.1. Текущий и рекомендуемый


| Компонент        | Технология             | Обоснование                                               |
| ---------------- | ---------------------- | --------------------------------------------------------- |
| **Backend**      | FastAPI                | Уже используется, асинхронность, автодокументация OpenAPI |
| **ORM**          | SQLAlchemy 2.0 (async) | Есть в проекте, зрелая экосистема                         |
| **БД**           | PostgreSQL             | JSON-поля, индексы, надёжность                            |
| **Миграции**     | Alembic                | Стандарт для SQLAlchemy                                   |
| **Валидация**    | Pydantic v2            | Интеграция с FastAPI, схемы request/response              |
| **Логирование**  | Loguru                 | Уже используется                                          |
| **Конфигурация** | pydantic-settings      | Поддержка .env, валидация                                 |


### 5.2. Рекомендуемые дополнения


| Компонент                | Технология                      | Обоснование                                        |
| ------------------------ | ------------------------------- | -------------------------------------------------- |
| **Полнотекстовый поиск** | PostgreSQL `tsvector` / pg_trgm | Поиск по имени, заметкам, интересам                |
| **Авторизация**          | JWT или OAuth2                  | Защита API при мультитенантности                   |
| **Тесты**                | pytest, pytest-asyncio, httpx   | Unit и интеграционные тесты                        |
| **Документация**         | OpenAPI (встроено) + ReDoc      | Уже настроено в FastAPI                            |
| **Фронтенд (позже)**     | HTML, CSS, JS                   | Классический веб; разработка после API (API-first) |


---

## 6. API: структура и эндпоинты

### 6.1. Принципы

- REST-подход.
- Версионирование: `/api/v1/`.
- Пагинация: `page`, `per_page` (или cursor-based для больших объёмов).
- Фильтры через query-параметры.

### 6.2. Эндпоинты (целевые)


| Метод    | Путь                                 | Описание                                    |
| -------- | ------------------------------------ | ------------------------------------------- |
| `GET`    | `/api/v1/contacts`                   | Список карточек (пагинация, поиск, фильтры) |
| `POST`   | `/api/v1/contacts`                   | Создать карточку                            |
| `GET`    | `/api/v1/contacts/{id}`              | Карточка по ID (с links, interactions)      |
| `PATCH`  | `/api/v1/contacts/{id}`              | Обновить карточку (частичное)               |
| `DELETE` | `/api/v1/contacts/{id}`              | Удалить карточку                            |
| `GET`    | `/api/v1/contacts/{id}/interactions` | История взаимодействий                      |
| `POST`   | `/api/v1/contacts/{id}/interactions` | Добавить взаимодействие                     |
| `GET`    | `/api/v1/contacts/{id}/links`        | Связи контакта с другими (граф)             |
| `POST`   | `/api/v1/contacts/{id}/links`        | Добавить связь с другим контактом           |
| `GET`    | `/api/v1/links`                     | Все связи (для визуализации графа)          |
| `GET`    | `/api/v1/search`                     | Полнотекстовый поиск по картотеке           |


### 6.3. Фильтры для `/api/v1/contacts`

- `q` — поиск по имени, email, заметкам
- `relationship_type` — business / personal / other
- `has_birthday_soon` — дни рождения в ближайшие N дней
- `last_contact_before` — не общались более N дней
- `sort` — по имени, last_contact_at, created_at

---

## 7. Структура директорий (рекомендуемая)

```
personal_networking/
├── alembic/                    # Миграции
├── docs/                       # Документация
│   ├── ARCHITECTURE.md
│   └── DEVELOPMENT_PLAN.md
├── sources/
│   ├── api/
│   │   ├── data_base/          # DB, models, DAO
│   │   │   ├── base.py
│   │   │   ├── models.py
│   │   │   └── repositories/   # Конкретные DAO
│   │   ├── routers/
│   │   │   └── v1/
│   │   │       ├── contacts.py
│   │   │       ├── interactions.py
│   │   │       └── links.py
│   │   ├── schemas/            # Pydantic-схемы
│   │   │   ├── contact.py
│   │   │   └── interaction.py
│   │   ├── services/           # Бизнес-логика
│   │   │   └── contact_service.py
│   │   └── fastapi_app.py
│   ├── main.py
│   ├── settings.py
│   └── utils/
└── tests/
    ├── unit/
    └── integration/
```

---

## 8. Нефункциональные требования


| Аспект                    | Рекомендация                                                                       |
| ------------------------- | ---------------------------------------------------------------------------------- |
| **Масштабируемость**      | Stateless API, пул соединений к БД, при необходимости — кэш (Redis)                |
| **Безопасность**          | HTTPS, CORS, валидация входных данных, при мультитенантности — изоляция по user_id |
| **Аудит**                 | Логирование изменений (создание/обновление/удаление карточек)                      |
| **Резервное копирование** | Регулярный бэкап PostgreSQL                                                        |


---

## 9. Риски и допущения


| Риск                                | Митигация                                             |
| ----------------------------------- | ----------------------------------------------------- |
| Рост объёма данных (200k+ карточек) | Индексы, пагинация, возможно партиционирование        |
| Конфиденциальность данных           | Шифрование в покое (БД), доступ только по авторизации |
| Сложность поиска по JSON-полям      | GIN-индексы по JSONB, полнотекстовый поиск            |


**Допущения:**

- Изначально — один пользователь (или без авторизации для MVP).
- Фронтенд — отдельный этап; **сначала API, затем веб-интерфейс** (HTML/CSS/JS).
- Импорт/экспорт — планируется на более поздних фазах.

---

## 10. Перспективы: ИИ-агент

Картотека содержит структурированные данные о контактах — идеальный контекст для ИИ-агента, который помогает поддерживать отношения.

### 10.1. Идеи применения


| Сценарий                          | Описание                                                                                                                                                 |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Напоминания о днях рождения**   | Агент отслеживает `birthday` у контактов и членов семьи, напоминает за N дней, предлагает идеи подарков или тему для сообщения (по интересам/хобби).     |
| **Напоминания об обещаниях**      | Агент мониторит `promises` и `follow_up_by`, уведомляет: «Ты обещал Иванову перезвонить до пятницы» или «Петров обещал прислать отчёт — пора напомнить». |
| **Забытые контакты**              | «С кем давно не общался» — по `last_contact_at` предлагает список людей для follow-up и краткую выжимку для возобновления разговора.                     |
| **Подготовка к встрече**          | Перед календарной встречей агент формирует «памятку»: последний контакт, незакрытые обещания, интересы, семейные новости.                                |
| **Персонализированные подсказки** | На основе интересов и заметок: «У Сидорова скоро ДР сына — он увлекается футболом», «Кузнецова упоминала переезд — спроси, как дела».                    |
| **Связи между контактами**        | «Кого можно попросить познакомить с X» — при наличии связей (ContactLink) агент предлагает интро.                                                        |
| **Еженедельный дайджест**         | Сводка: предстоящие ДР, просроченные обещания, контакты без общения N дней.                                                                              |


### 10.2. Архитектурные предпосылки

- Единый API и единый источник данных — агент работает с теми же эндпоинтами, что и веб/мобильное приложение.
- Структурированные поля (promises, interests, last_contact_at) упрощают промпты и снижают «галлюцинации».
- Реализация — отдельный сервис (воркер, cron, или event-driven), который периодически опрашивает API или подписывается на события.

---

## 11. Перспективы: мобильное приложение

### 11.1. Концепция

Мобильное приложение как **синхронизируемый клиент**: данные, введённые в мобильном приложении, попадают на сервер и отображаются в веб-версии (и наоборот).

### 11.2. Модель синхронизации


| Подход                   | Описание                                                                                      | Плюсы                              | Минусы                                |
| ------------------------ | --------------------------------------------------------------------------------------------- | ---------------------------------- | ------------------------------------- |
| **Онлайн-first**         | Все операции идут через API, локальный кэш только для оффлайна                                | Простота, всегда актуальные данные | Зависимость от сети                   |
| **Оффлайн-first + синк** | Данные пишутся локально (SQLite), очередь синхронизации при появлении сети                    | Работа без интернета               | Сложнее: конфликты, merge             |
| **Гибрид**               | Основной режим — онлайн, при отсутствии сети — локальная очередь с последующей синхронизацией | Баланс UX и сложности              | Нужна стратегия разрешения конфликтов |


### 11.3. Рекомендации

- **API-first** — мобильное приложение использует тот же REST API, что и веб.
- **Версионирование сущностей** — поле `updated_at` или `version` для определения «кто новее» при конфликтах.
- **Стратегия конфликтов** — last-write-wins или ручное слияние (показывать пользователю оба варианта).
- **Push-уведомления** — для напоминаний от ИИ-агента (Firebase, APNs и т.п.).

### 11.4. Технологии (на будущее)

- **Кросс-платформа:** Flutter, React Native — единая кодовая база для iOS/Android.
- **Нативные:** Swift (iOS), Kotlin (Android) — при приоритете нативного UX.
- **API:** тот же FastAPI, аутентификация через JWT.

---

*Документ подготовлен как архитектурное видение. Детали реализации уточняются в DEVELOPMENT_PLAN.md и по мере обратной связи.*